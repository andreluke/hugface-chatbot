DESENVOLVIMENTO DE SISTEMAS MULTIPLATAFORMA (DSM) - MATERIAL COMPLETO

=== INTRODUÇÃO AO DESENVOLVIMENTO MULTIPLATAFORMA ===

O Desenvolvimento Multiplataforma refere-se à criação de aplicações que podem executar em múltiplas plataformas (iOS, Android, Web, Desktop) usando uma única base de código ou com mínimas modificações.

Tipos de Desenvolvimento:
- Nativo: Desenvolvimento específico para cada plataforma (Swift/Objective-C para iOS, Java/Kotlin para Android)
- Cross-platform: Uma base de código para múltiplas plataformas
- Híbrido: Aplicações web executadas em containers nativos
- PWA (Progressive Web App): Aplicações web com capacidades nativas

Vantagens do Desenvolvimento Multiplataforma:
- Redução de custos de desenvolvimento (uma equipe, um código)
- Tempo de desenvolvimento mais rápido
- Manutenção centralizada
- Consistência entre plataformas
- Aproveitamento de conhecimento web existente
- Deploy simultâneo para múltiplas plataformas

Desvantagens:
- Performance pode ser inferior ao nativo
- Acesso limitado a APIs específicas da plataforma
- Dependência de frameworks terceiros
- Curva de aprendizado de novas tecnologias
- Possíveis inconsistências na experiência do usuário

=== PRINCIPAIS FRAMEWORKS MULTIPLATAFORMA ===

REACT NATIVE - FRAMEWORK META/FACEBOOK:

Características Técnicas:
- Linguagem: JavaScript/TypeScript com sintaxe React
- Criado por: Meta (Facebook) em 2015
- Renderização: Componentes nativos reais (não WebView)
- Performance: Excelente para maioria dos casos de uso
- Hot Reload: Desenvolvimento rápido com atualizações instantâneas
- Comunidade: Muito grande, ecossistema maduro
- Curva de Aprendizado: Fácil se você já conhece React/JavaScript

Empresas que Usam:
- Instagram, Facebook, WhatsApp (Meta)
- Uber, Uber Eats (transporte e delivery)
- Airbnb (antes, migrou para nativo depois)
- Discord (comunicação)
- Pinterest (redes sociais)
- Tesla (aplicativo do carro)

Vantagens do React Native:
- Renderização nativa real (performance próxima ao nativo)
- Reutilização de código web existente
- Grande biblioteca de componentes terceiros
- Suporte oficial da Meta
- Bridge para código nativo quando necessário
- Hermes engine para melhor performance JavaScript

Desvantagens:
- Bridge JavaScript pode ser gargalo em casos específicos
- Atualizações de versão podem quebrar dependências
- Algumas APIs nativas requerem código platform-específico
- Tamanho do bundle pode ser grande

FLUTTER - FRAMEWORK GOOGLE:

Características Técnicas:
- Linguagem: Dart (desenvolvida pelo Google)
- Criado por: Google em 2017
- Renderização: Engine própria usando Skia (controle total dos pixels)
- Performance: Próxima ao nativo, 60fps consistente
- Hot Reload: Muito rápido, preserva estado da aplicação
- Widget-based: Tudo é widget, UI declarativa
- Curva de Aprendizado: Moderada, Dart é específica para Flutter

Empresas que Usam:
- Google Pay, Google Ads (Google)
- BMW, Toyota (automotivo)
- Alibaba, Tencent (e-commerce chinês)
- Nubank, C6 Bank (fintechs brasileiras)
- eBay Motors (marketplace)
- Hamilton Musical (entretenimento)

Vantagens do Flutter:
- Performance consistente 60fps
- UI totalmente customizável (controle de pixels)
- Compilação para múltiplas plataformas (mobile, web, desktop)
- Dart é otimizada para UI
- Material Design e Cupertino widgets built-in
- Tooling excelente (DevTools, Hot Reload)

Desvantagens:
- Dart é linguagem nova (curva de aprendizado)
- Comunidade menor que React Native
- Tamanho do APK pode ser grande
- Menos bibliotecas terceiras comparado ao React Native

IONIC - FRAMEWORK HÍBRIDO:

Características Técnicas:
- Linguagem: HTML, CSS, JavaScript/TypeScript
- Baseado em: Angular (padrão), React ou Vue.js
- Renderização: WebView com plugins nativos
- Performance: Boa para apps não intensivos
- Capacitor: Bridge moderno para recursos nativos
- Deploy: Web, iOS, Android, Electron (desktop)

Vantagens do Ionic:
- Aproveita conhecimento web existente
- Uma base de código para web, mobile e desktop
- Desenvolvimento rápido para MVPs
- Grande flexibilidade de UI (CSS completo)
- Integração fácil com APIs web
- Community plugins para recursos nativos

Desvantagens:
- Performance inferior para animações complexas
- Dependente de WebView (pode variar entre dispositivos)
- UX pode não parecer completamente nativa
- Limitações em aplicações que requerem alta performance

XAMARIN - FRAMEWORK MICROSOFT:

Características Técnicas:
- Linguagem: C# e .NET
- Xamarin.Forms: UI compartilhada
- Xamarin.Native: UI específica por plataforma
- Performance: Próxima ao nativo
- Integração: Visual Studio, Azure DevOps

Vantagens:
- Aproveita conhecimento .NET/C#
- Performance próxima ao nativo
- Acesso completo a APIs nativas
- Tooling Microsoft robusto

Status Atual:
- Microsoft está focando em .NET MAUI (evolução do Xamarin)
- Xamarin.Forms em manutenção, migração recomendada para MAUI

=== ARQUITETURAS DE SOFTWARE MÓVEL DETALHADAS ===

ARQUITETURAS PARA DESENVOLVIMENTO MOBILE:

MVVM (Model-View-ViewModel) - RECOMENDADO PARA MAIORIA DOS CASOS:

Conceitos MVVM:
- Model: Dados e lógica de negócio (APIs, database, business rules)
- View: Componentes UI (screens, widgets, components)  
- ViewModel: Conecta dados à UI (hooks customizados, stores, controllers)
- Vantagem Principal: Data binding facilita sincronização automática

Implementação MVVM em React Native:
```javascript
// Model (API/Data)
class UserRepository {
  async getUser(id) {
    return fetch(`/api/users/${id}`).then(res => res.json());
  }
}

// ViewModel (Hook customizado)
function useUser(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const fetchUser = useCallback(async () => {
    setLoading(true);
    const userData = await userRepository.getUser(userId);
    setUser(userData);
    setLoading(false);
  }, [userId]);
  
  return { user, loading, fetchUser };
}

// View (Component)
function UserScreen({ userId }) {
  const { user, loading, fetchUser } = useUser(userId);
  
  return (
    <View>
      {loading ? <Loading /> : <UserDetails user={user} />}
    </View>
  );
}
```

Implementação MVVM em Flutter:
```dart
// Model
class User {
  final String id;
  final String name;
  User({required this.id, required this.name});
}

// ViewModel (com ChangeNotifier)
class UserViewModel extends ChangeNotifier {
  User? _user;
  bool _isLoading = false;
  
  User? get user => _user;
  bool get isLoading => _isLoading;
  
  Future<void> loadUser(String userId) async {
    _isLoading = true;
    notifyListeners();
    
    _user = await UserRepository().getUser(userId);
    _isLoading = false;
    notifyListeners();
  }
}

// View (Widget)
class UserScreen extends StatelessWidget {
  Widget build(BuildContext context) {
    return Consumer<UserViewModel>(
      builder: (context, viewModel, child) {
        return viewModel.isLoading 
          ? CircularProgressIndicator()
          : UserDetails(user: viewModel.user);
      },
    );
  }
}
```

CLEAN ARCHITECTURE - PARA PROJETOS GRANDES E COMPLEXOS:

Estrutura Clean Architecture Flutter:
```
lib/
├── core/                    # Utilitários compartilhados
│   ├── error/              # Error handling
│   ├── network/            # Network utilities  
│   └── usecases/           # Base usecase
├── features/               # Funcionalidades por módulo
│   └── user/
│       ├── data/           # Data layer
│       │   ├── datasources/    # APIs, local storage
│       │   │   ├── user_remote_datasource.dart
│       │   │   └── user_local_datasource.dart
│       │   ├── models/         # DTOs e conversões
│       │   │   └── user_model.dart
│       │   └── repositories/   # Repository implementations
│       │       └── user_repository_impl.dart
│       ├── domain/         # Domain layer (regras de negócio)
│       │   ├── entities/       # Business objects
│       │   │   └── user.dart
│       │   ├── repositories/   # Repository contracts/interfaces
│       │   │   └── user_repository.dart
│       │   └── usecases/       # Business logic
│       │       ├── get_user.dart
│       │       └── update_user.dart
│       └── presentation/   # Presentation layer
│           ├── bloc/           # State management
│           │   ├── user_bloc.dart
│           │   ├── user_event.dart
│           │   └── user_state.dart
│           ├── pages/          # UI screens
│           │   └── user_page.dart
│           └── widgets/        # UI components
│               └── user_card.dart
```

Camadas Clean Architecture:

Domain Layer (Regras de Negócio):
- Entities: Classes que representam conceitos de negócio puros
- Use Cases: Casos de uso específicos da aplicação
- Repository Interfaces: Contratos para acesso a dados (abstrações)
- Independente de frameworks, UI ou database

Data Layer (Fontes de Dados):
- Models: Conversão entre JSON/Database e entidades
- Data Sources: APIs REST, GraphQL, SQLite, SharedPreferences
- Repository Implementations: Implementação concreta dos contratos

Presentation Layer (Interface com Usuário):
- Bloc/Cubit/Provider: Gerenciamento de estado e eventos
- Pages: Telas principais da aplicação
- Widgets: Componentes reutilizáveis da interface

Dependências Clean Architecture (pubspec.yaml):
```yaml
dependencies:
  # Dependency Injection
  get_it: ^7.2.0
  injectable: ^2.1.0
  
  # State Management  
  flutter_bloc: ^8.1.1
  
  # Value Equality
  equatable: ^2.0.5
  
  # Functional Programming
  dartz: ^0.10.1
  
  # Network
  dio: ^5.1.0
  
  # Local Storage
  shared_preferences: ^2.1.0
```

MVC (Model-View-Controller) - SIMPLES MAS LIMITADO:

Características MVC:
- Model: Dados e lógica de negócio
- View: Interface do usuário (telas, componentes)
- Controller: Lógica de controle e coordenação
- Problema Principal: Controllers podem ficar muito grandes (God Object)

Quando Usar MVC:
- Projetos pequenos e simples
- Prototipação rápida
- Equipes pequenas
- Quando não há complexidade de estado

GERENCIAMENTO DE ESTADO - ESTRATÉGIAS POR FRAMEWORK:

React Native State Management:
- Redux com Redux Toolkit: Estado global complexo, time travel debugging
- Context API: Estado global simples, built-in no React
- Zustand: Alternativa leve ao Redux, menos boilerplate
- React Query/TanStack Query: Server state management
- AsyncStorage: Persistência local simples

Flutter State Management:
- Provider: Dependency injection e estado simples, recomendado pelo Google
- Bloc Pattern: Estado complexo, event-driven, alta testabilidade
- Riverpod: Evolução do Provider, mais type-safe e poderoso
- GetX: All-in-one (state + navigation + DI), produtivo mas controverso
- Hive/SharedPreferences: Persistência local

Padrões Avançados de Estado:
- Separação UI State vs Business State
- Normalização de dados (evitar nested objects)
- Optimistic Updates (assumir sucesso antes de confirmação)
- Caching Strategies (memory, disk, network)
- Offline-first approaches (sync quando conectar)

COMPARISON: REACT NATIVE VS FLUTTER ARQUITETURA:

React Native Architecture:
- Component-based com JSX
- Virtual DOM com reconciliation
- Bridge para comunicação com código nativo
- Hot Reload preserva estado parcialmente
- JavaScript single-thread com event loop

Flutter Architecture:  
- Widget-based com tudo sendo widget
- Renderização direta via Skia engine
- Dart compila para ARM nativo
- Hot Reload preserva estado completo
- Dart single-thread com isolates para concorrência

Escolha de Arquitetura Baseada no Contexto:
- Equipe com conhecimento JavaScript/React: React Native + MVVM/Redux
- Performance crítica ou UI muito customizada: Flutter + Clean Architecture
- Time iniciante em mobile: React Native + Context API (menos complexo)
- Controle total da UI e animações: Flutter + Bloc Pattern
- Projeto empresarial grande: Clean Architecture em qualquer framework

=== COMPONENTES E REUTILIZAÇÃO ===

Componentização:
- Divisão da UI em componentes reutilizáveis
- Encapsulamento de lógica e estilo
- Props/Parameters para customização
- Facilita manutenção e testes
- Atomic Design: Atoms, Molecules, Organisms

Design Systems:
- Biblioteca de componentes padronizados
- Guias de estilo e tokens de design
- Consistência visual entre plataformas
- Facilita colaboração entre times
- Exemplos: Material Design, Human Interface Guidelines

=== TESTES EM DESENVOLVIMENTO MULTIPLATAFORMA ===

TESTES EM REACT NATIVE - STACK COMPLETA:

Testes Unitários:
- Jest: Framework padrão para JavaScript/TypeScript
- Teste funções utilitárias e lógica de negócio
- Configure em jest.config.js
- Mocking de módulos nativos com jest.mock()
- Cobertura de código com --coverage flag
- Exemplo: teste de funções de validação, cálculos, utilitários

Testes de Componentes:
- React Native Testing Library: Melhor prática para testar componentes
- Renderização e interações com componentes React Native
- Melhor que Enzyme para React Native (mais atualizado)
- fireEvent para simular interações do usuário
- waitFor para aguardar mudanças assíncronas
- Exemplo: renderizar componente, simular tap, verificar mudança de estado

Testes E2E (End-to-End):
- Detox: Específico para React Native, desenvolvido pela Wix
- Appium: Cross-platform, mais complexo de configurar
- Maestro: Alternativa moderna e mais simples
- Cavy: Framework leve para testes E2E
- WebDriverIO: Para apps híbridos

Ferramentas Auxiliares:
- Flipper: Debugging durante desenvolvimento
- React Native Debugger: Debug específico para RN
- Storybook: Para desenvolvimento isolado de componentes

TESTES EM FLUTTER - IMPLEMENTAÇÃO COMPLETA:

Testes Unitários (Base da Pirâmide):
- Use o package flutter_test incluído por padrão no Flutter
- Teste funções, classes e lógica de negócio isoladamente
- Execute todos os testes com comando flutter test
- Meta recomendada: +80% cobertura das regras de negócio
- Mockito para criar mocks de dependências
- Organize testes em grupos para melhor estruturação

Testes de Widget:
- Teste componentes UI individuais de forma isolada
- Use WidgetTester para simular interações (tap, scroll, input de texto)
- Verifique se widgets renderizam corretamente
- Exemplo básico: await tester.pumpWidget(MyWidget())
- TestWidgets para ambiente de teste completo
- Golden tests para comparação visual pixel-perfect

Testes de Integração:
- Use flutter_driver (legado) ou integration_test (recomendado)
- Teste fluxos completos da aplicação end-to-end
- Simule interações reais do usuário em dispositivos
- Pode rodar em dispositivos físicos ou emuladores
- Mais lentos que testes unitários, use com moderação

Ferramentas Extras para Flutter:
- Mockito: Para criar mocks de dependências externas
- Golden Tests: Para comparação visual exata de widgets
- Patrol: Alternativa moderna ao Flutter Driver
- Very Good CLI: Ferramentas para setup de testes

Comando para executar todos os testes: flutter test

ESTRATÉGIAS DE TESTE MULTIPLATAFORMA:

Pirâmide de Testes:
- Base (70%): Testes Unitários - rápidos, isolados, baratos
- Meio (20%): Testes de Integração - componentes juntos
- Topo (10%): Testes E2E - interface completa, caros

Test-Driven Development (TDD):
- Red: Escreva teste que falha
- Green: Implemente mínimo para passar
- Refactor: Melhore o código mantendo testes verdes

Behavior-Driven Development (BDD):
- Given-When-Then para cenários de teste
- Cucumber/Gherkin para especificações
- Aproxima testes da linguagem de negócio

Testes de Acessibilidade:
- Screen reader compatibility
- Color contrast validation  
- Keyboard navigation
- Focus management
- Semantic markup verification

Testes de Performance:
- Bundle size analysis
- Memory leak detection
- Frame rate monitoring (60fps target)
- Cold start time measurement
- Battery usage profiling

=== PERFORMANCE E OTIMIZAÇÃO MULTIPLATAFORMA ===

OTIMIZAÇÃO DE PERFORMANCE EM REACT NATIVE:

Otimização de Listas (Problema Comum):
- NUNCA use ScrollView + map() para listas grandes
- Use FlatList com renderização virtualizada
- Configure getItemLayout para performance máxima quando altura é fixa
- removeClippedSubviews={true} para melhor memory usage
- maxToRenderPerBatch e windowSize para controle de renderização

Exemplo de FlatList Otimizada:
```javascript
<FlatList
  data={data}
  keyExtractor={item => item.id}
  renderItem={({item}) => <ItemComponent item={item} />}
  removeClippedSubviews={true}
  maxToRenderPerBatch={10}
  windowSize={10}
  initialNumToRender={10}
  updateCellsBatchingPeriod={50}
  getItemLayout={(data, index) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index,
    index,
  })}
/>
```

Otimizações de Re-renders:
- React.memo() para componentes puros (evita re-renders desnecessários)
- useMemo() para cálculos pesados (memoização de valores)
- useCallback() para funções passadas como props
- Evite criação de objetos inline nas props (style={{}} é ruim)
- Separe estado local de estado global

Exemplo de Componente Otimizado:
```javascript
const ItemComponent = React.memo(({item, onPress}) => {
  return (
    <TouchableOpacity onPress={onPress} style={styles.item}>
      <Text>{item.title}</Text>
    </TouchableOpacity>
  );
}, (prevProps, nextProps) => {
  // Custom comparison function
  return prevProps.item.id === nextProps.item.id;
});
```

Performance de Bundle:
- Hermes JavaScript Engine: Melhor startup time e memory usage
- Bundle splitting: Separar código em chunks
- Code splitting: Lazy loading de telas
- Metro bundler optimization: Configurar .metro.config.js
- Flipper para profiling e debugging de performance

Ferramentas de Debug Performance:
- Flipper: Monitor integrado para React Native
- React DevTools: Profile de componentes React
- enableVirtualization debug: Mostra área de renderização
- Performance Monitor: FPS, memory, bridge utilization

OTIMIZAÇÃO DE PERFORMANCE EM FLUTTER:

Widget Rebuilding Optimization:
- Use const constructors sempre que possível (evita rebuilds)
- Evite rebuilds desnecessários com keys corretas
- Separe widgets que mudam de widgets estáticos
- Use RepaintBoundary para isolate repaints
- Builder pattern para rebuilds localizados

Otimizações de Listas Flutter:
- ListView.builder() para listas grandes (lazy loading)
- CustomScrollView com Slivers para listas complexas
- AutomaticKeepAliveClientMixin para manter estado de itens
- itemExtent quando altura é fixa (melhor performance)
- cacheExtent para controlar cache de widgets

Exemplo ListView Otimizado Flutter:
```dart
ListView.builder(
  itemCount: items.length,
  itemExtent: 100.0, // Fixed height
  cacheExtent: 1000.0, // Cache extra widgets
  itemBuilder: (context, index) {
    return ListTile(
      key: ValueKey(items[index].id),
      title: Text(items[index].title),
    );
  },
)
```

Flutter Performance Tools:
- Flutter DevTools: Profiling completo (CPU, memory, widgets)
- Performance overlay: showPerformanceOverlay = true
- Widget Inspector: Debugging de widget tree
- Timeline view: Análise frame-by-frame
- Memory view: Leak detection

OTIMIZAÇÕES GERAIS MULTIPLATAFORMA:

Image Optimization:
- Lazy loading de imagens (react-native-fast-image, cached_network_image)
- Compression e resize automático
- WebP format quando suportado
- Placeholder images para melhor UX
- Image caching para evitar re-downloads

Network Optimization:
- HTTP caching com cache headers
- Request deduplication (evitar requests duplicados)
- Batch requests quando possível
- Gzip compression
- CDN para assets estáticos

Memory Management:
- Dispose de controllers e listeners
- Weak references onde apropriado
- Lazy initialization de recursos
- Object pooling para objetos frequentes
- Memory profiling regular

Startup Performance:
- Splash screen otimizada
- Lazy loading de módulos não críticos
- Preload de dados essenciais
- Background initialization
- Code splitting para reduzir bundle inicial

Animações Performance:
- Use native animations (Animated API no RN, AnimationController no Flutter)
- Avoid layout-triggering animations
- useNativeDriver: true no React Native
- 60fps target para smooth UX
- Reduce overdraw e complex layouts

Battery Optimization:
- Background task management
- Network request optimization
- Location services efficient usage
- Push notifications ao invés de polling
- CPU-intensive task optimization

=== CI/CD E DEPLOYMENT PARA DESENVOLVIMENTO MOBILE ===

CI/CD PARA REACT NATIVE - GUIA COMPLETO:

Setup GitHub Actions para React Native:
```yaml
name: React Native CI
on: [push, pull_request]
jobs:
  test-and-build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm install
      - run: npm test
      - run: npx react-native build-android --mode=release
```

Ferramentas Essenciais para React Native:
- Fastlane: Automação de deploy para App Store e Google Play
- CodePush: Updates over-the-air da Microsoft (sem passar pelas lojas)
- Firebase App Distribution: Beta testing e distribuição interna
- Bitrise: CI/CD específico para mobile
- GitHub Actions: CI/CD integrado ao GitHub

Pipeline Típico React Native:
1. Build: Compilar código JavaScript e bundles nativos para Android/iOS
2. Test: Executar Jest (unitários) + Detox (E2E)
3. Code Quality: ESLint, Prettier, TypeScript check
4. Deploy: Google Play Store + Apple App Store

Configuração Fastlane para React Native:
```ruby
platform :android do
  lane :beta do
    gradle(task: "assembleRelease")
    supply(track: "beta", skip_upload_apk: false)
  end
  
  lane :production do
    gradle(task: "bundleRelease")
    upload_to_play_store
  end
end

platform :ios do
  lane :beta do
    build_app(scheme: "MyApp")
    upload_to_testflight
  end
  
  lane :production do
    build_app(scheme: "MyApp")
    upload_to_app_store
  end
end
```

Deploy Automático React Native:
- Google Play Store: fastlane supply (upload direto)
- Apple App Store: fastlane deliver (review necessário)
- CodePush: appcenter codepush release-react (bypass das lojas)
- Firebase App Distribution: firebase appdistribution:distribute

CI/CD PARA FLUTTER - IMPLEMENTAÇÃO COMPLETA:

GitHub Actions para Flutter:
```yaml
name: Flutter CI
on: [push, pull_request]
jobs:
  test-and-build:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.x'
      - run: flutter pub get
      - run: flutter test
      - run: flutter build apk --release
      - run: flutter build ios --release --no-codesign
```

Pipeline Flutter Típico:
1. Dependencies: flutter pub get para instalar dependências
2. Analysis: flutter analyze para análise estática
3. Test: flutter test para testes unitários e de widget
4. Build: flutter build para compilar releases
5. Deploy: Upload para stores usando Fastlane

Fastlane com Flutter:
```ruby
platform :android do
  lane :deploy do
    sh "flutter build appbundle --release"
    upload_to_play_store(
      aab: "../build/app/outputs/bundle/release/app-release.aab"
    )
  end
end
```

CI/CD MULTIPLATAFORMA - FERRAMENTAS GERAIS:

Plataformas CI/CD Populares:
- GitHub Actions: Integrado ao GitHub, gratuito para projetos públicos
- GitLab CI: Integrado ao GitLab, runners próprios ou compartilhados
- Bitrise: Focado em mobile, interface visual amigável
- CircleCI: Popular para projetos complexos, configuração flexível
- Azure DevOps: Integração com ecossistema Microsoft

Estratégias de Deploy:

Deploy para Google Play Store:
- Fastlane supply plugin para upload automático
- Google Play Console API para gestão programática
- Staged rollout: deploy gradual (5% → 25% → 50% → 100%)
- Internal testing → Closed testing → Open testing → Production

Deploy para Apple App Store:
- Fastlane deliver plugin para upload
- App Store Connect API para automação
- TestFlight para beta testing
- App Store review process (pode levar dias)

Updates Over-The-Air (OTA):
- React Native: Microsoft CodePush (descontinuado, usar Expo Updates)
- Flutter: Shorebird para hot updates
- Ionic: Appflow Live Updates
- Bypassa review das lojas para mudanças JavaScript/Dart

Beta Testing e Distribuição:
- TestFlight: Beta testing oficial da Apple
- Firebase App Distribution: Multiplataforma, gratuito
- Google Play Internal Testing: Para testes rápidos Android
- Diawi: Upload manual para distribuição interna

Signing e Certificados:
- Android: Keystore management, Play App Signing
- iOS: Certificates, Provisioning Profiles, Fastlane Match
- Automatização: fastlane match para gestão centralizada
- Segurança: Nunca commitar chaves/certificados no código

Monitoramento e Analytics:
- Crashlytics: Tracking de crashes em produção
- Firebase Analytics: Métricas de uso e engagement
- Sentry: Error tracking e performance monitoring
- New Relic: Performance monitoring detalhado

CI/CD BEST PRACTICES:

Build Optimization:
- Cache de dependências (node_modules, pub cache)
- Build paralelo quando possível
- Incremental builds para reduzir tempo
- Docker para ambientes consistentes

Quality Gates:
- Code coverage mínimo (80%+ recomendado)
- Linting obrigatório (ESLint, dart analyze)
- Security scans (npm audit, dependências)
- Performance budgets (bundle size limits)

Branching Strategy:
- GitFlow: feature → develop → release → main
- GitHub Flow: feature → main (mais simples)
- Release branches para hotfixes
- Protected branches com required checks

Environment Management:
- Separate configs para dev/staging/prod
- Environment variables para secrets
- Feature flags para releases graduais
- Blue-green deployments para zero downtime

=== GERENCIAMENTO DE ESTADO ===

React Native:
- Redux com Redux Toolkit
- Context API para estado global simples
- Zustand como alternativa leve
- React Query para server state
- AsyncStorage para persistência

Flutter:
- Provider para dependency injection
- Bloc pattern para complex state
- Riverpod como evolução do Provider
- GetX para state management completo
- Hive ou SharedPreferences para persistência

Padrões Comuns:
- Separação entre UI state e business state
- Normalização de dados
- Optimistic updates
- Caching strategies
- Offline-first approaches

=== BOAS PRÁTICAS E METODOLOGIAS ===

Código Limpo:
- Nomenclatura clara e consistente
- Funções pequenas e focadas
- Comentários quando necessário
- Refactoring constante
- SOLID principles

Versionamento:
- Semantic Versioning (SemVer)
- Git flow ou GitHub flow
- Conventional commits
- Changelog maintenance
- Branch protection rules

Acessibilidade:
- Screen reader support
- Adequate color contrast
- Focus management
- Semantic elements
- Testing with assistive technologies

Segurança:
- Secure storage para dados sensíveis
- Certificate pinning
- Obfuscação de código
- Input validation
- OWASP Mobile Security guidelines

=== FERRAMENTAS DE DESENVOLVIMENTO ===

IDEs e Editores:
- Visual Studio Code com extensões
- Android Studio para desenvolvimento Android
- Xcode para desenvolvimento iOS
- IntelliJ IDEA como alternativa

Debugging e Profiling:
- React Native Debugger
- Flipper para React Native
- Flutter DevTools
- Chrome DevTools
- Sentry para error tracking

Design e Prototipagem:
- Figma para design de interfaces
- Adobe XD como alternativa
- Sketch para macOS
- InVision para prototipagem interativa

Versionamento e Colaboração:
- Git para controle de versão
- GitHub, GitLab ou Bitbucket
- Pull/Merge requests
- Code review processes